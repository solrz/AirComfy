<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirComfy</title>
    <link rel="stylesheet" href="style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="description" content="Minimal PWA for ComfyUI workflow execution">
    <script src="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js"></script>
</head>
<body v-scope>
    <header>
        <h1>AirComfy <span v-if="debugMode" class="debug-badge">DEBUG</span></h1>
        <div class="connection-status" :class="connectionStatus.toLowerCase()">
            {{ connectionStatus }}
        </div>
    </header>

    <main>
        <!-- System Stats Button -->
        <button @click="showSystemStats" class="stats-btn" title="View System Stats">üìä</button>

        <!-- Main View -->
        <div v-if="currentView === 'main'" class="view">
            <section class="config-section">
                <h2>ComfyUI Configuration</h2>
                <div class="debug-controls" v-if="debugMode">
                    <button @click="toggleDebugMode" class="debug-btn">üêõ Debug Mode: ON</button>
                    <button @click="clearDebugPresets" class="tertiary-btn">Clear Debug Presets</button>
                </div>
                <div class="debug-controls" v-else>
                    <button @click="toggleDebugMode" class="tertiary-btn">üêõ Enable Debug Mode</button>
                </div>
                <div class="input-group">
                    <label for="serverEndpoint">Server Endpoint:</label>
                    <div class="endpoint-selector">
                        <select v-model="selectedEndpointId" @change="selectEndpoint" class="endpoint-dropdown">
                            <option value="">Select an endpoint...</option>
                            <option v-for="endpoint in endpoints" :key="endpoint.id" :value="endpoint.id">
                                {{ endpoint.name }} ({{ endpoint.url }})
                            </option>
                        </select>
                        <button @click="showEndpointManager" class="secondary-btn">Manage Endpoints</button>
                    </div>
                </div>
                <button @click="connect" class="primary-btn">Connect</button>
            </section>

            <section class="workflow-section">
                <h2>Workflow</h2>
                <div class="workflow-input-area">
                    <div class="workflow-status">{{ workflowStatus }}</div>
                    <div class="workflow-actions">
                        <button @click="triggerFileUpload" class="secondary-btn">
                            üìÅ Upload JSON
                        </button>
                        <button @click="pasteFromClipboard" class="secondary-btn">
                            üìã Paste from Clipboard
                        </button>
                        <button @click="clearWorkflow" class="tertiary-btn">Clear</button>
                    </div>
                    <input id="workflow-file-input" type="file" accept=".json" @change="handleFileUpload" style="display: none;">
                </div>
                <div v-if="currentWorkflow" class="workflow-preview">
                    <div class="workflow-tabs">
                        <button @click="switchToPreview" :class="{active: workflowViewMode === 'preview'}" class="tab-btn">Preview</button>
                        <button @click="switchToEditor" :class="{active: workflowViewMode === 'editor'}" class="tab-btn">Editor</button>
                    </div>

                    <div v-if="workflowViewMode === 'preview'" class="workflow-preview-content">
                        <pre>{{ workflowPreview }}</pre>
                    </div>

                    <div v-if="workflowViewMode === 'editor'" class="workflow-editor" id="workflow-editor-container">
                        <!-- Editor content will be rendered here by JavaScript -->
                    </div>
                </div>
                <div class="execution-actions">
                    <button @click="validateWorkflow" class="secondary-btn">Validate</button>
                    <button @click="executeWorkflow" :disabled="!canExecute" class="primary-btn">Execute</button>
                </div>
            </section>

            <section class="results-section">
                <h2>Results</h2>
                <div class="status-display" :class="status.type">{{ status.message }}</div>
                <div class="progress-display">{{ progress }}</div>
                <div class="results-display">
                    <img v-for="image in resultImages" :key="image.src" :src="image.src" :alt="image.alt" class="result-image">
                    <p v-if="resultImages.length === 0 && progress === 'Complete'">No images generated</p>
                </div>
            </section>
        </div>

        <!-- Endpoint Manager View -->
        <div v-if="currentView === 'endpoints'" class="view">
            <section class="endpoint-manager-section">
                <div class="view-header">
                    <h2>Manage Endpoints</h2>
                    <button @click="showMainView" class="secondary-btn">‚Üê Back</button>
                </div>

                <div class="endpoint-form">
                    <h3>Add New Endpoint</h3>
                    <div class="input-group">
                        <label for="endpointName">Endpoint Name:</label>
                        <input v-model="newEndpoint.name" type="text" placeholder="e.g., Local Server">
                    </div>
                    <div class="input-group">
                        <label for="endpointUrl">Endpoint URL:</label>
                        <input v-model="newEndpoint.url" type="url" placeholder="http://localhost:8188">
                    </div>
                    <button @click="addEndpoint" class="primary-btn">Add Endpoint</button>
                </div>

                <div class="endpoint-list">
                    <h3>Saved Endpoints</h3>
                    <div v-if="endpoints.length === 0" class="no-endpoints-message">
                        No endpoints saved yet.
                    </div>
                    <div v-for="endpoint in endpoints" :key="endpoint.id" class="endpoint-item">
                        <div class="endpoint-info">
                            <div class="endpoint-name">{{ endpoint.name }}</div>
                            <div class="endpoint-url">{{ endpoint.url }}</div>
                        </div>
                        <div class="endpoint-actions">
                            <button @click="editEndpoint(endpoint)" class="icon-btn edit-btn" title="Edit">‚úèÔ∏è</button>
                            <button @click="deleteEndpoint(endpoint.id)" class="icon-btn delete-btn" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <!-- System Stats View -->
        <div v-if="currentView === 'stats'" class="view">
            <section class="stats-section">
                <div class="view-header">
                    <h2>System Statistics</h2>
                    <button @click="showMainView" class="secondary-btn">‚Üê Back</button>
                </div>

                <div class="stats-content">
                    <div class="stats-refresh">
                        <button @click="fetchSystemStats" class="primary-btn">Refresh Stats</button>
                        <span class="stats-timestamp" v-if="statsTimestamp">Last updated: {{ statsTimestamp }}</span>
                    </div>

                    <div v-if="systemStats" class="stats-display">
                        <div class="stat-group">
                            <h3>System Info</h3>
                            <div class="stat-item">
                                <span class="stat-label">Python Version:</span>
                                <span class="stat-value">{{ systemStats.system?.python_version || 'N/A' }}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Embedded Python:</span>
                                <span class="stat-value">{{ systemStats.system?.embedded_python || false }}</span>
                            </div>
                        </div>

                        <div class="stat-group" v-if="systemStats.devices">
                            <h3>GPU Devices</h3>
                            <div v-for="(device, index) in systemStats.devices" :key="index" class="device-info">
                                <div class="stat-item">
                                    <span class="stat-label">Device {{ index }}:</span>
                                    <span class="stat-value">{{ device.name }}</span>
                                </div>
                                <div class="stat-item" v-if="device.vram_total">
                                    <span class="stat-label">VRAM:</span>
                                    <span class="stat-value">{{ formatBytes(device.vram_used_torch) }} / {{ formatBytes(device.vram_total) }}</span>
                                </div>
                                <div class="stat-item" v-if="device.vram_free">
                                    <span class="stat-label">Free VRAM:</span>
                                    <span class="stat-value">{{ formatBytes(device.vram_free) }}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Type:</span>
                                    <span class="stat-value">{{ device.type }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="stat-group">
                            <h3>Raw Data</h3>
                            <pre class="stats-raw">{{ JSON.stringify(systemStats, null, 2) }}</pre>
                        </div>
                    </div>

                    <div v-else class="no-stats-message">
                        Click "Refresh Stats" to load system statistics
                    </div>

                    <!-- Workflow Logs Section -->
                    <div class="workflow-logs-section">
                        <div class="logs-header">
                            <h3>Workflow Execution History</h3>
                            <button @click="clearWorkflowLogs" class="tertiary-btn" v-if="workflowLogs.length > 0">Clear Logs</button>
                        </div>

                        <div v-if="workflowLogs.length > 0" class="logs-container">
                            <div v-for="(log, index) in workflowLogs.slice().reverse()" :key="index" class="log-entry" :class="'log-' + log.status">
                                <div class="log-header">
                                    <span class="log-timestamp">{{ new Date(log.timestamp).toLocaleString() }}</span>
                                    <span class="log-status" :class="'status-' + log.status">{{ log.status.toUpperCase() }}</span>
                                </div>
                                <div class="log-details">
                                    <div class="log-item">
                                        <span class="log-label">Workflow:</span>
                                        <span class="log-value">{{ log.workflowName }}</span>
                                    </div>
                                    <div class="log-item">
                                        <span class="log-label">Server:</span>
                                        <span class="log-value">{{ log.serverUrl }}</span>
                                    </div>
                                    <div class="log-item" v-if="log.promptId">
                                        <span class="log-label">Prompt ID:</span>
                                        <span class="log-value">{{ log.promptId }}</span>
                                    </div>
                                    <div class="log-item">
                                        <span class="log-label">Nodes:</span>
                                        <span class="log-value">{{ log.nodeCount }}</span>
                                    </div>
                                    <div class="log-item" v-if="log.executionTime">
                                        <span class="log-label">Submit Time:</span>
                                        <span class="log-value">{{ formatDuration(log.executionTime) }}</span>
                                    </div>
                                    <div class="log-item" v-if="log.totalTime">
                                        <span class="log-label">Total Time:</span>
                                        <span class="log-value">{{ formatDuration(log.totalTime) }}</span>
                                    </div>
                                    <div class="log-item" v-if="log.error">
                                        <span class="log-label">Error:</span>
                                        <span class="log-value error-text">{{ log.error }}</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div v-else class="no-logs-message">
                            No workflow executions logged yet
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        // Store app reference globally for debugging
        window.$app = null;

        function AirComfyApp() {
            const app = {
                // Reactive state
                currentView: 'main',
                connectionStatus: 'Disconnected',
                systemStats: null,
                statsTimestamp: '',
                serverUrl: '',
                clientId: '',
                websocket: null,
                currentPromptId: null,
                currentWorkflow: null,
                endpoints: [],
                selectedEndpointId: '',
                workflowStatus: 'No workflow loaded',
                status: { message: '', type: 'info' },
                progress: '',
                resultImages: [],
                newEndpoint: { name: '', url: '' },
                debugMode: false,
                workflowLogs: [],
                workflowViewMode: 'preview',
                workflowNodes: {},
                hiddenNodes: {},

                // Computed properties
                get canExecute() {
                    return this.connectionStatus === 'Connected' && this.currentWorkflow;
                },
                get workflowPreview() {
                    return this.currentWorkflow ? JSON.stringify(this.currentWorkflow, null, 2) : '';
                },

                // Lifecycle
                mounted() {
                    this.clientId = this.generateClientId();
                    this.loadEndpoints();
                    this.loadSettings();
                    this.loadWorkflowLogs();
                    this.registerServiceWorker();
                    this.checkDebugMode();
                },

                generateClientId() {
                    return Math.random().toString(36).substring(2) + Date.now().toString(36);
                },

                // Debug mode management
                checkDebugMode() {
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.has('debug')) {
                        this.debugMode = urlParams.get('debug') === 'true';
                        this.saveSettings();

                        if (this.debugMode) {
                            this.loadDebugPresets();
                        }
                    }
                },

                async loadDebugPresets() {
                    // Load preset workflow
                    const debugWorkflow = localStorage.getItem('aircomfy-debug-workflow');
                    if (debugWorkflow) {
                        this.loadWorkflow(debugWorkflow, 'Debug preset workflow loaded');
                    } else {
                        // Default SD15 workflow for testing
                        const defaultWorkflow = {
                            "3": {
                                "inputs": {
                                    "seed": 156680208700286,
                                    "steps": 20,
                                    "cfg": 8,
                                    "sampler_name": "euler",
                                    "scheduler": "normal",
                                    "denoise": 1,
                                    "model": ["4", 0],
                                    "positive": ["6", 0],
                                    "negative": ["7", 0],
                                    "latent_image": ["5", 0]
                                },
                                "class_type": "KSampler"
                            },
                            "4": {
                                "inputs": {
                                    "ckpt_name": "v1-5-pruned-emaonly.safetensors"
                                },
                                "class_type": "CheckpointLoaderSimple"
                            },
                            "5": {
                                "inputs": {
                                    "width": 512,
                                    "height": 512,
                                    "batch_size": 1
                                },
                                "class_type": "EmptyLatentImage"
                            },
                            "6": {
                                "inputs": {
                                    "text": "beautiful scenery nature glass bottle landscape, purple galaxy bottle",
                                    "clip": ["4", 1]
                                },
                                "class_type": "CLIPTextEncode"
                            },
                            "7": {
                                "inputs": {
                                    "text": "text, watermark",
                                    "clip": ["4", 1]
                                },
                                "class_type": "CLIPTextEncode"
                            },
                            "8": {
                                "inputs": {
                                    "samples": ["3", 0],
                                    "vae": ["4", 2]
                                },
                                "class_type": "VAEDecode"
                            },
                            "9": {
                                "inputs": {
                                    "filename_prefix": "ComfyUI",
                                    "images": ["8", 0]
                                },
                                "class_type": "SaveImage"
                            }
                        };
                        this.loadWorkflow(JSON.stringify(defaultWorkflow), 'Debug preset workflow loaded');
                    }

                    // Load preset endpoint
                    const debugEndpointId = localStorage.getItem('aircomfy-debug-endpoint');
                    if (debugEndpointId && this.endpoints.find(e => e.id === debugEndpointId)) {
                        this.selectedEndpointId = debugEndpointId;
                        this.selectEndpoint();
                    } else {
                        // Use first available endpoint or localhost
                        const localEndpoint = this.endpoints.find(e => e.url.includes('localhost:8188'));
                        if (localEndpoint) {
                            this.selectedEndpointId = localEndpoint.id;
                            this.selectEndpoint();
                        } else if (this.endpoints.length > 0) {
                            this.selectedEndpointId = this.endpoints[0].id;
                            this.selectEndpoint();
                        }
                    }

                    // Auto-connect if endpoint is selected
                    if (this.selectedEndpointId) {
                        setTimeout(() => this.connect(), 500);
                    }
                },

                toggleDebugMode() {
                    this.debugMode = !this.debugMode;
                    this.saveSettings();

                    if (this.debugMode) {
                        // Save current state as debug presets
                        if (this.currentWorkflow) {
                            localStorage.setItem('aircomfy-debug-workflow', JSON.stringify(this.currentWorkflow));
                        }
                        if (this.selectedEndpointId) {
                            localStorage.setItem('aircomfy-debug-endpoint', this.selectedEndpointId);
                        }
                        this.updateStatus('Debug mode enabled - presets saved', 'info');
                    } else {
                        this.updateStatus('Debug mode disabled', 'info');
                    }
                },

                clearDebugPresets() {
                    localStorage.removeItem('aircomfy-debug-workflow');
                    localStorage.removeItem('aircomfy-debug-endpoint');
                    this.updateStatus('Debug presets cleared', 'info');
                },

                // Settings management
                loadSettings() {
                    const saved = localStorage.getItem('aircomfy-settings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        this.selectedEndpointId = settings.selectedEndpointId || '';
                        this.debugMode = settings.debugMode || false;
                        if (this.selectedEndpointId) {
                            const endpoint = this.endpoints.find(e => e.id === this.selectedEndpointId);
                            if (endpoint) {
                                this.serverUrl = endpoint.url;
                            }
                        }
                    }
                },

                saveSettings() {
                    const settings = {
                        selectedEndpointId: this.selectedEndpointId,
                        debugMode: this.debugMode
                    };
                    localStorage.setItem('aircomfy-settings', JSON.stringify(settings));
                },

                // Connection methods
                async connect() {
                    if (!this.serverUrl) {
                        this.updateStatus('Please select a server endpoint', 'error');
                        return;
                    }

                    this.saveSettings();

                    try {
                        const response = await fetch(`${this.serverUrl}/system_stats`, {
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        if (response.ok) {
                            this.connectionStatus = 'Connected';
                            this.connectWebSocket();
                            this.updateStatus('Connected to ComfyUI server', 'success');
                        } else {
                            throw new Error(`Server responded with ${response.status}`);
                        }
                    } catch (error) {
                        this.connectionStatus = 'Disconnected';

                        if (error.message.includes('fetch') || error.name === 'TypeError') {
                            this.updateStatus(`CORS blocked: Use proxy or serve PWA from ComfyUI server directly`, 'error');
                        } else {
                            this.updateStatus(`Connection failed: ${error.message}`, 'error');
                        }
                    }
                },

                connectWebSocket() {
                    const wsUrl = this.serverUrl.replace('http', 'ws') + `/ws?clientId=${this.clientId}`;

                    if (this.websocket) {
                        this.websocket.close();
                    }

                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        this.updateStatus('WebSocket connected', 'success');
                    };

                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };

                    this.websocket.onclose = () => {
                        this.updateStatus('WebSocket disconnected', 'warning');
                    };

                    this.websocket.onerror = (error) => {
                        this.updateStatus('WebSocket error occurred', 'error');
                    };
                },

                // WebSocket message handling
                handleWebSocketMessage(data) {
                    if (data.type === 'status') {
                        this.progress = `Queue: ${data.data.status.exec_info.queue_remaining}`;
                    } else if (data.type === 'progress') {
                        const progress = Math.round((data.data.value / data.data.max) * 100);
                        this.progress = `Progress: ${progress}% (${data.data.node})`;
                    } else if (data.type === 'executed') {
                        this.handleExecutionComplete(data.data);
                    }
                },

                // Workflow management
                triggerFileUpload() {
                    const fileInput = document.getElementById('workflow-file-input');
                    if (fileInput) {
                        fileInput.click();
                    }
                },

                async handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    if (!file.name.endsWith('.json')) {
                        this.updateStatus('Please select a JSON file', 'error');
                        return;
                    }

                    try {
                        const text = await file.text();
                        this.loadWorkflow(text, `Uploaded: ${file.name}`);
                    } catch (error) {
                        this.updateStatus(`Failed to read file: ${error.message}`, 'error');
                    }

                    event.target.value = '';
                },

                async pasteFromClipboard() {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (!text.trim()) {
                            this.updateStatus('Clipboard is empty', 'error');
                            return;
                        }
                        this.loadWorkflow(text, 'Pasted from clipboard');
                    } catch (error) {
                        this.updateStatus('Failed to read clipboard. Use Ctrl+V manually.', 'error');
                    }
                },

                loadWorkflow(workflowText, source) {
                    try {
                        const workflow = JSON.parse(workflowText);
                        if (typeof workflow !== 'object' || !workflow) {
                            throw new Error('Invalid JSON format');
                        }

                        this.currentWorkflow = workflow;
                        this.workflowStatus = source;
                        this.extractWorkflowNodes();
                        this.updateStatus('Workflow loaded successfully', 'success');
                    } catch (error) {
                        this.updateStatus(`Invalid workflow: ${error.message}`, 'error');
                    }
                },

                extractWorkflowNodes() {
                    // Check if workflow has the prompt wrapper
                    const nodes = this.currentWorkflow.prompt || this.currentWorkflow;

                    // Create new objects to ensure reactivity
                    const newNodes = {};
                    const newHidden = {};

                    // Extract all nodes and their fields
                    for (const [nodeId, node] of Object.entries(nodes)) {
                        if (typeof node === 'object' && node !== null) {
                            newNodes[nodeId] = {
                                class_type: node.class_type || 'Unknown',
                                inputs: node.inputs || {}
                            };
                            // Initially show all nodes
                            newHidden[nodeId] = false;
                        }
                    }

                    // Assign new objects to trigger reactivity
                    this.workflowNodes = newNodes;
                    this.hiddenNodes = newHidden;
                },

                formatArrayValue(arr) {
                    if (!Array.isArray(arr)) return '';
                    return `[${arr.join(', ')}]`;
                },

                updateNodeField(nodeId, field, value, type) {
                    if (!this.workflowNodes[nodeId]) return;

                    let processedValue = value;

                    switch(type) {
                        case 'number':
                            processedValue = parseFloat(value) || 0;
                            break;
                        case 'boolean':
                            processedValue = value;
                            break;
                        case 'array':
                            // Parse array input like "[4, 0]" or "4, 0"
                            const cleaned = value.replace(/[\[\]]/g, '').trim();
                            if (cleaned) {
                                const parts = cleaned.split(',').map(p => {
                                    const trimmed = p.trim();
                                    // Try to parse as number, otherwise keep as string
                                    const num = parseFloat(trimmed);
                                    return isNaN(num) ? trimmed : num;
                                });
                                processedValue = parts;
                            } else {
                                processedValue = [];
                            }
                            break;
                        case 'string':
                        default:
                            processedValue = value;
                            break;
                    }

                    // Update the node field
                    this.workflowNodes[nodeId].inputs[field] = processedValue;

                    // Also update the original workflow
                    if (this.currentWorkflow.prompt) {
                        this.currentWorkflow.prompt[nodeId].inputs[field] = processedValue;
                    } else {
                        this.currentWorkflow[nodeId].inputs[field] = processedValue;
                    }
                },

                toggleNodeVisibility(nodeId) {
                    this.hiddenNodes[nodeId] = !this.hiddenNodes[nodeId];
                    // Re-render editor when toggling visibility
                    if (this.workflowViewMode === 'editor') {
                        this.renderEditor();
                    }
                },

                showAllNodes() {
                    for (const nodeId in this.hiddenNodes) {
                        this.hiddenNodes[nodeId] = false;
                    }
                    // Re-render editor
                    if (this.workflowViewMode === 'editor') {
                        this.renderEditor();
                    }
                },

                hideAllNodes() {
                    for (const nodeId in this.hiddenNodes) {
                        this.hiddenNodes[nodeId] = true;
                    }
                    // Re-render editor
                    if (this.workflowViewMode === 'editor') {
                        this.renderEditor();
                    }
                },

                switchToPreview() {
                    this.workflowViewMode = 'preview';
                },

                switchToEditor() {
                    this.workflowViewMode = 'editor';
                    // Re-extract nodes to ensure they're available
                    if (this.currentWorkflow && Object.keys(this.workflowNodes).length === 0) {
                        this.extractWorkflowNodes();
                    }
                    // Render the editor after switching
                    setTimeout(() => this.renderEditor(), 10);
                },

                renderEditor() {
                    const container = document.getElementById('workflow-editor-container');
                    if (!container || !this.currentWorkflow) return;

                    let html = `
                        <div class="editor-controls">
                            <button onclick="window.$app.showAllNodes()" class="secondary-btn">Show All Hidden Nodes</button>
                            <button onclick="window.$app.hideAllNodes()" class="secondary-btn">Hide All Nodes</button>
                        </div>
                    `;

                    // Render each node
                    for (const [nodeId, node] of Object.entries(this.workflowNodes)) {
                        const isHidden = this.hiddenNodes[nodeId] || false;

                        html += `
                            <div class="node-group">
                                <div class="node-header">
                                    <h4>Node ${nodeId}: ${node.class_type}</h4>
                                    <button onclick="window.$app.toggleNodeVisibility('${nodeId}')" class="toggle-btn">
                                        ${isHidden ? 'üëÅÔ∏è Show' : 'üôà Hide'}
                                    </button>
                                </div>
                        `;

                        if (!isHidden) {
                            html += '<div class="node-fields">';

                            for (const [field, value] of Object.entries(node.inputs)) {
                                // Skip fields that are connected to other nodes (have array values)
                                if (Array.isArray(value)) {
                                    continue; // Skip this field as it's connected to another node
                                }

                                const fieldId = `node-${nodeId}-${field}`;
                                html += `
                                    <div class="field-group">
                                        <label for="${fieldId}" class="field-label">${field}:</label>
                                `;

                                if (typeof value === 'boolean') {
                                    // Boolean input
                                    html += `
                                        <input
                                            id="${fieldId}"
                                            type="checkbox"
                                            ${value ? 'checked' : ''}
                                            onchange="window.$app.updateNodeField('${nodeId}', '${field}', this.checked, 'boolean')"
                                            class="field-checkbox">
                                    `;
                                } else if (typeof value === 'number') {
                                    // Number input
                                    html += `
                                        <input
                                            id="${fieldId}"
                                            type="number"
                                            value="${value}"
                                            onchange="window.$app.updateNodeField('${nodeId}', '${field}', this.value, 'number')"
                                            class="field-input"
                                            step="any">
                                    `;
                                } else if (field === 'text' || field === 'prompt') {
                                    // Textarea for text fields
                                    html += `
                                        <textarea
                                            id="${fieldId}"
                                            onchange="window.$app.updateNodeField('${nodeId}', '${field}', this.value, 'string')"
                                            class="field-textarea"
                                            rows="3">${value || ''}</textarea>
                                    `;
                                } else {
                                    // Text input
                                    html += `
                                        <input
                                            id="${fieldId}"
                                            type="text"
                                            value="${value || ''}"
                                            onchange="window.$app.updateNodeField('${nodeId}', '${field}', this.value, 'string')"
                                            class="field-input">
                                    `;
                                }

                                html += '</div>';
                            }

                            html += '</div>';
                        }

                        html += '</div>';
                    }

                    container.innerHTML = html;
                },

                clearWorkflow() {
                    this.currentWorkflow = null;
                    this.workflowStatus = 'No workflow loaded';
                    this.workflowNodes = {};
                    this.hiddenNodes = {};
                    this.workflowViewMode = 'preview';
                    this.updateStatus('Workflow cleared', 'info');
                },

                validateWorkflow() {
                    if (!this.currentWorkflow) {
                        this.updateStatus('Please load a workflow first', 'error');
                        return false;
                    }

                    try {
                        if (typeof this.currentWorkflow !== 'object' || !this.currentWorkflow) {
                            throw new Error('Invalid workflow format');
                        }
                        this.updateStatus('Workflow validation passed', 'success');
                        return true;
                    } catch (error) {
                        this.updateStatus(`Workflow validation failed: ${error.message}`, 'error');
                        return false;
                    }
                },

                async executeWorkflow() {
                    if (!this.validateWorkflow()) return;
                    if (!this.serverUrl) {
                        this.updateStatus('Please connect to server first', 'error');
                        return;
                    }

                    // Check if workflow already has the correct structure
                    let promptData;
                    if (this.currentWorkflow.prompt && this.currentWorkflow.client_id) {
                        // Already in correct format (pre-wrapped)
                        promptData = this.currentWorkflow;
                        // Update client_id to current session
                        promptData.client_id = this.clientId;
                    } else {
                        // Raw workflow nodes - need to wrap
                        promptData = {
                            prompt: this.currentWorkflow,
                            client_id: this.clientId
                        };
                    }

                    // Create log entry for workflow submission
                    const logEntry = {
                        timestamp: new Date().toISOString(),
                        promptId: null,
                        serverUrl: this.serverUrl,
                        workflowName: this.workflowStatus,
                        nodeCount: Object.keys(this.currentWorkflow.prompt || this.currentWorkflow).length,
                        status: 'pending',
                        error: null,
                        executionTime: null,
                        startTime: Date.now()
                    };

                    try {
                        this.updateStatus('Submitting workflow...', 'info');
                        const response = await fetch(`${this.serverUrl}/prompt`, {
                            method: 'POST',
                            mode: 'cors',
                            credentials: 'omit',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(promptData)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            this.currentPromptId = result.prompt_id;
                            logEntry.promptId = result.prompt_id;
                            logEntry.status = 'submitted';
                            logEntry.executionTime = Date.now() - logEntry.startTime;
                            this.addWorkflowLog(logEntry);
                            this.updateStatus(`Workflow submitted. Prompt ID: ${this.currentPromptId}`, 'success');
                        } else {
                            throw new Error(`Server error: ${response.status}`);
                        }
                    } catch (error) {
                        logEntry.status = 'failed';
                        logEntry.error = error.message;
                        logEntry.executionTime = Date.now() - logEntry.startTime;
                        this.addWorkflowLog(logEntry);
                        this.updateStatus(`Execution failed: ${error.message}`, 'error');
                    }
                },

                async handleExecutionComplete(data) {
                    if (data.prompt_id === this.currentPromptId) {
                        this.updateStatus('Workflow execution completed', 'success');
                        this.progress = 'Complete';

                        // Update log entry for completed workflow
                        const logIndex = this.workflowLogs.findIndex(log => log.promptId === this.currentPromptId);
                        if (logIndex !== -1) {
                            this.workflowLogs[logIndex].status = 'completed';
                            this.workflowLogs[logIndex].completedTime = Date.now();
                            this.workflowLogs[logIndex].totalTime = Date.now() - this.workflowLogs[logIndex].startTime;
                            this.saveWorkflowLogs();
                        }

                        try {
                            const historyResponse = await fetch(`${this.serverUrl}/history/${this.currentPromptId}`, {
                                mode: 'cors',
                                credentials: 'omit'
                            });
                            if (historyResponse.ok) {
                                const history = await historyResponse.json();
                                this.displayResults(history);
                            }
                        } catch (error) {
                            this.updateStatus(`Failed to fetch results: ${error.message}`, 'error');
                        }
                    }
                },

                displayResults(history) {
                    this.resultImages = [];

                    for (const [promptId, promptData] of Object.entries(history)) {
                        if (promptData.outputs) {
                            for (const [nodeId, nodeOutput] of Object.entries(promptData.outputs)) {
                                if (nodeOutput.images) {
                                    nodeOutput.images.forEach(image => {
                                        this.resultImages.push({
                                            src: `${this.serverUrl}/view?filename=${image.filename}&subfolder=${image.subfolder}&type=${image.type}`,
                                            alt: `Generated image from node ${nodeId}`
                                        });
                                    });
                                }
                            }
                        }
                    }
                },

                updateStatus(message, type = 'info') {
                    this.status = { message, type };
                },

                async registerServiceWorker() {
                    if ('serviceWorker' in navigator) {
                        try {
                            await navigator.serviceWorker.register('./sw.js');
                        } catch (error) {
                            console.warn('Service Worker registration failed');
                        }
                    }
                },

                // Endpoint management
                loadEndpoints() {
                    const saved = localStorage.getItem('aircomfy-endpoints');
                    if (saved) {
                        this.endpoints = JSON.parse(saved);
                    } else {
                        // Add default endpoint
                        this.endpoints = [
                            {
                                id: this.generateEndpointId(),
                                name: 'Local Server',
                                url: 'http://localhost:8188'
                            }
                        ];
                        this.saveEndpoints();
                    }
                },

                saveEndpoints() {
                    localStorage.setItem('aircomfy-endpoints', JSON.stringify(this.endpoints));
                },

                generateEndpointId() {
                    return 'endpoint-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
                },

                // View navigation
                showEndpointManager() {
                    this.currentView = 'endpoints';
                },

                showMainView() {
                    this.currentView = 'main';
                },

                selectEndpoint() {
                    const endpoint = this.endpoints.find(e => e.id === this.selectedEndpointId);
                    if (endpoint) {
                        this.serverUrl = endpoint.url;
                        this.saveSettings();
                        this.connectionStatus = 'Disconnected';
                    } else {
                        this.selectedEndpointId = '';
                        this.serverUrl = '';
                    }
                },

                addEndpoint() {
                    const name = this.newEndpoint.name.trim();
                    const url = this.newEndpoint.url.trim();

                    if (!name || !url) {
                        alert('Please enter both name and URL for the endpoint');
                        return;
                    }

                    try {
                        new URL(url); // Validate URL format
                    } catch (e) {
                        alert('Please enter a valid URL');
                        return;
                    }

                    const endpoint = {
                        id: this.generateEndpointId(),
                        name: name,
                        url: url
                    };

                    this.endpoints.push(endpoint);
                    this.saveEndpoints();

                    // Clear form
                    this.newEndpoint.name = '';
                    this.newEndpoint.url = '';
                },

                deleteEndpoint(endpointId) {
                    if (confirm('Are you sure you want to delete this endpoint?')) {
                        this.endpoints = this.endpoints.filter(e => e.id !== endpointId);
                        this.saveEndpoints();

                        // Clear selection if deleted endpoint was selected
                        if (this.selectedEndpointId === endpointId) {
                            this.selectedEndpointId = '';
                            this.serverUrl = '';
                            this.saveSettings();
                        }
                    }
                },

                editEndpoint(endpoint) {
                    const newName = prompt('Enter new name:', endpoint.name);
                    if (newName && newName.trim()) {
                        const newUrl = prompt('Enter new URL:', endpoint.url);
                        if (newUrl && newUrl.trim()) {
                            try {
                                new URL(newUrl); // Validate URL format
                                endpoint.name = newName.trim();
                                endpoint.url = newUrl.trim();
                                this.saveEndpoints();

                                // Update server URL if this endpoint is selected
                                if (this.selectedEndpointId === endpoint.id) {
                                    this.serverUrl = endpoint.url;
                                }
                            } catch (e) {
                                alert('Please enter a valid URL');
                            }
                        }
                    }
                },

                // System Stats methods
                showSystemStats() {
                    this.currentView = 'stats';
                    if (this.serverUrl && !this.systemStats) {
                        this.fetchSystemStats();
                    }
                },

                async fetchSystemStats() {
                    if (!this.serverUrl) {
                        this.updateStatus('Please connect to a server first', 'error');
                        return;
                    }

                    try {
                        const response = await fetch(`${this.serverUrl}/system_stats`, {
                            mode: 'cors',
                            credentials: 'omit'
                        });

                        if (response.ok) {
                            this.systemStats = await response.json();
                            this.statsTimestamp = new Date().toLocaleTimeString();
                            this.updateStatus('System stats loaded', 'success');
                        } else {
                            throw new Error(`Failed to fetch stats: ${response.status}`);
                        }
                    } catch (error) {
                        this.updateStatus(`Failed to load system stats: ${error.message}`, 'error');
                    }
                },

                formatBytes(bytes) {
                    if (!bytes) return '0 B';
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
                },

                // Workflow logs management
                loadWorkflowLogs() {
                    const saved = localStorage.getItem('aircomfy-workflow-logs');
                    if (saved) {
                        this.workflowLogs = JSON.parse(saved);
                        // Keep only last 100 logs
                        if (this.workflowLogs.length > 100) {
                            this.workflowLogs = this.workflowLogs.slice(-100);
                            this.saveWorkflowLogs();
                        }
                    }
                },

                saveWorkflowLogs() {
                    localStorage.setItem('aircomfy-workflow-logs', JSON.stringify(this.workflowLogs));
                },

                addWorkflowLog(logEntry) {
                    this.workflowLogs.push(logEntry);
                    // Keep only last 100 logs
                    if (this.workflowLogs.length > 100) {
                        this.workflowLogs.shift();
                    }
                    this.saveWorkflowLogs();
                },

                clearWorkflowLogs() {
                    if (confirm('Are you sure you want to clear all workflow logs?')) {
                        this.workflowLogs = [];
                        this.saveWorkflowLogs();
                        this.updateStatus('Workflow logs cleared', 'info');
                    }
                },

                formatDuration(ms) {
                    if (ms < 1000) return ms + 'ms';
                    const seconds = Math.floor(ms / 1000);
                    const minutes = Math.floor(seconds / 60);
                    if (minutes > 0) {
                        return `${minutes}m ${seconds % 60}s`;
                    }
                    return `${seconds}s`;
                }
            };

            // Store app reference globally
            window.$app = app;
            return app;
        }

        // Initialize the Vue app
        PetiteVue.createApp(AirComfyApp()).mount();
    </script>
</body>
</html>