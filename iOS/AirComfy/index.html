<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirComfy</title>
    <link rel="stylesheet" href="style.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="description" content="Minimal PWA for ComfyUI workflow execution">
    <script src="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js"></script>
</head>
<body v-scope="AirComfyApp()" @vue:mounted="mounted">
    <header>
        <h1>AirComfy</h1>
        <div class="connection-status" :class="connectionStatus.toLowerCase()">
            {{ connectionStatus }}
        </div>
    </header>

    <main>
        <!-- Main View -->
        <div v-show="currentView === 'main'" class="view">
            <section class="config-section">
                <h2>ComfyUI Configuration</h2>
                <div class="input-group">
                    <label for="serverEndpoint">Server Endpoint:</label>
                    <div class="endpoint-selector">
                        <select v-model="selectedEndpointId" @change="selectEndpoint" class="endpoint-dropdown">
                            <option value="">Select an endpoint...</option>
                            <option v-for="endpoint in endpoints" :key="endpoint.id" :value="endpoint.id">
                                {{ endpoint.name }} ({{ endpoint.url }})
                            </option>
                        </select>
                        <button @click="showEndpointManager" class="secondary-btn">Manage Endpoints</button>
                    </div>
                </div>
                <button @click="connect" class="primary-btn">Connect</button>
            </section>

            <section class="workflow-section">
                <h2>Workflow</h2>
                <div class="workflow-input-area">
                    <div class="workflow-status">{{ workflowStatus }}</div>
                    <div class="workflow-actions">
                        <button @click="triggerFileUpload" class="secondary-btn">
                            üìÅ Upload JSON
                        </button>
                        <button @click="pasteFromClipboard" class="secondary-btn">
                            üìã Paste from Clipboard
                        </button>
                        <button @click="clearWorkflow" class="tertiary-btn">Clear</button>
                    </div>
                    <input ref="fileInput" type="file" accept=".json" @change="handleFileUpload" style="display: none;">
                </div>
                <div v-show="currentWorkflow" class="workflow-preview">
                    <h3>Workflow Preview</h3>
                    <pre>{{ workflowPreview }}</pre>
                </div>
                <div class="execution-actions">
                    <button @click="validateWorkflow" class="secondary-btn">Validate</button>
                    <button @click="executeWorkflow" :disabled="!canExecute" class="primary-btn">Execute</button>
                </div>
            </section>

            <section class="results-section">
                <h2>Results</h2>
                <div class="status-display" :class="status.type">{{ status.message }}</div>
                <div class="progress-display">{{ progress }}</div>
                <div class="results-display">
                    <img v-for="image in resultImages" :key="image.src" :src="image.src" :alt="image.alt" class="result-image">
                    <p v-if="resultImages.length === 0 && progress === 'Complete'">No images generated</p>
                </div>
            </section>
        </div>

        <!-- Endpoint Manager View -->
        <div v-show="currentView === 'endpoints'" class="view">
            <section class="endpoint-manager-section">
                <div class="view-header">
                    <h2>Manage Endpoints</h2>
                    <button @click="showMainView" class="secondary-btn">‚Üê Back</button>
                </div>

                <div class="endpoint-form">
                    <h3>Add New Endpoint</h3>
                    <div class="input-group">
                        <label for="endpointName">Endpoint Name:</label>
                        <input v-model="newEndpoint.name" type="text" placeholder="e.g., Local Server">
                    </div>
                    <div class="input-group">
                        <label for="endpointUrl">Endpoint URL:</label>
                        <input v-model="newEndpoint.url" type="url" placeholder="http://localhost:8188">
                    </div>
                    <button @click="addEndpoint" class="primary-btn">Add Endpoint</button>
                </div>

                <div class="endpoint-list">
                    <h3>Saved Endpoints</h3>
                    <div v-if="endpoints.length === 0" class="no-endpoints-message">
                        No endpoints saved yet.
                    </div>
                    <div v-for="endpoint in endpoints" :key="endpoint.id" class="endpoint-item">
                        <div class="endpoint-info">
                            <div class="endpoint-name">{{ endpoint.name }}</div>
                            <div class="endpoint-url">{{ endpoint.url }}</div>
                        </div>
                        <div class="endpoint-actions">
                            <button @click="editEndpoint(endpoint)" class="icon-btn edit-btn" title="Edit">‚úèÔ∏è</button>
                            <button @click="deleteEndpoint(endpoint.id)" class="icon-btn delete-btn" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        function AirComfyApp() {
            return {
                // Reactive state
                currentView: 'main',
                connectionStatus: 'Disconnected',
                serverUrl: '',
                clientId: '',
                websocket: null,
                currentPromptId: null,
                currentWorkflow: null,
                endpoints: [],
                selectedEndpointId: '',
                workflowStatus: 'No workflow loaded',
                status: { message: '', type: 'info' },
                progress: '',
                resultImages: [],
                newEndpoint: { name: '', url: '' },

                // Computed properties
                get canExecute() {
                    return this.connectionStatus === 'Connected' && this.currentWorkflow;
                },
                get workflowPreview() {
                    return this.currentWorkflow ? JSON.stringify(this.currentWorkflow, null, 2) : '';
                },

                // Lifecycle
                mounted() {
                    this.clientId = this.generateClientId();
                    this.loadEndpoints();
                    this.loadSettings();
                    this.registerServiceWorker();
                },

                generateClientId() {
                    return Math.random().toString(36).substring(2) + Date.now().toString(36);
                },

                // Settings management
                loadSettings() {
                    const saved = localStorage.getItem('aircomfy-settings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        this.selectedEndpointId = settings.selectedEndpointId || '';
                        if (this.selectedEndpointId) {
                            const endpoint = this.endpoints.find(e => e.id === this.selectedEndpointId);
                            if (endpoint) {
                                this.serverUrl = endpoint.url;
                            }
                        }
                    }
                },

                saveSettings() {
                    const settings = {
                        selectedEndpointId: this.selectedEndpointId
                    };
                    localStorage.setItem('aircomfy-settings', JSON.stringify(settings));
                },

                // Connection methods
                async connect() {
                    if (!this.serverUrl) {
                        this.updateStatus('Please select a server endpoint', 'error');
                        return;
                    }

                    this.saveSettings();

                    try {
                        const response = await fetch(`${this.serverUrl}/system_stats`, {
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        if (response.ok) {
                            this.connectionStatus = 'Connected';
                            this.connectWebSocket();
                            this.updateStatus('Connected to ComfyUI server', 'success');
                        } else {
                            throw new Error(`Server responded with ${response.status}`);
                        }
                    } catch (error) {
                        this.connectionStatus = 'Disconnected';

                        if (error.message.includes('fetch') || error.name === 'TypeError') {
                            this.updateStatus(`CORS blocked: Use proxy or serve PWA from ComfyUI server directly`, 'error');
                        } else {
                            this.updateStatus(`Connection failed: ${error.message}`, 'error');
                        }
                    }
                },

                connectWebSocket() {
                    const wsUrl = this.serverUrl.replace('http', 'ws') + `/ws?clientId=${this.clientId}`;

                    if (this.websocket) {
                        this.websocket.close();
                    }

                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        this.updateStatus('WebSocket connected', 'success');
                    };

                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };

                    this.websocket.onclose = () => {
                        this.updateStatus('WebSocket disconnected', 'warning');
                    };

                    this.websocket.onerror = (error) => {
                        this.updateStatus('WebSocket error occurred', 'error');
                    };
                },

                // WebSocket message handling
                handleWebSocketMessage(data) {
                    if (data.type === 'status') {
                        this.progress = `Queue: ${data.data.status.exec_info.queue_remaining}`;
                    } else if (data.type === 'progress') {
                        const progress = Math.round((data.data.value / data.data.max) * 100);
                        this.progress = `Progress: ${progress}% (${data.data.node})`;
                    } else if (data.type === 'executed') {
                        this.handleExecutionComplete(data.data);
                    }
                },

                // Workflow management
                triggerFileUpload() {
                    this.$refs.fileInput.click();
                },

                async handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    if (!file.name.endsWith('.json')) {
                        this.updateStatus('Please select a JSON file', 'error');
                        return;
                    }

                    try {
                        const text = await file.text();
                        this.loadWorkflow(text, `Uploaded: ${file.name}`);
                    } catch (error) {
                        this.updateStatus(`Failed to read file: ${error.message}`, 'error');
                    }

                    event.target.value = '';
                },

                async pasteFromClipboard() {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (!text.trim()) {
                            this.updateStatus('Clipboard is empty', 'error');
                            return;
                        }
                        this.loadWorkflow(text, 'Pasted from clipboard');
                    } catch (error) {
                        this.updateStatus('Failed to read clipboard. Use Ctrl+V manually.', 'error');
                    }
                },

                loadWorkflow(workflowText, source) {
                    try {
                        const workflow = JSON.parse(workflowText);
                        if (typeof workflow !== 'object' || !workflow) {
                            throw new Error('Invalid JSON format');
                        }

                        this.currentWorkflow = workflow;
                        this.workflowStatus = source;
                        this.updateStatus('Workflow loaded successfully', 'success');
                    } catch (error) {
                        this.updateStatus(`Invalid workflow: ${error.message}`, 'error');
                    }
                },

                clearWorkflow() {
                    this.currentWorkflow = null;
                    this.workflowStatus = 'No workflow loaded';
                    this.updateStatus('Workflow cleared', 'info');
                },

                validateWorkflow() {
                    if (!this.currentWorkflow) {
                        this.updateStatus('Please load a workflow first', 'error');
                        return false;
                    }

                    try {
                        if (typeof this.currentWorkflow !== 'object' || !this.currentWorkflow) {
                            throw new Error('Invalid workflow format');
                        }
                        this.updateStatus('Workflow validation passed', 'success');
                        return true;
                    } catch (error) {
                        this.updateStatus(`Workflow validation failed: ${error.message}`, 'error');
                        return false;
                    }
                },

                async executeWorkflow() {
                    if (!this.validateWorkflow()) return;
                    if (!this.serverUrl) {
                        this.updateStatus('Please connect to server first', 'error');
                        return;
                    }

                    // Check if workflow already has the correct structure
                    let promptData;
                    if (this.currentWorkflow.prompt && this.currentWorkflow.client_id) {
                        // Already in correct format (pre-wrapped)
                        promptData = this.currentWorkflow;
                        // Update client_id to current session
                        promptData.client_id = this.clientId;
                    } else {
                        // Raw workflow nodes - need to wrap
                        promptData = {
                            prompt: this.currentWorkflow,
                            client_id: this.clientId
                        };
                    }

                    try {
                        this.updateStatus('Submitting workflow...', 'info');
                        const response = await fetch(`${this.serverUrl}/prompt`, {
                            method: 'POST',
                            mode: 'cors',
                            credentials: 'omit',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(promptData)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            this.currentPromptId = result.prompt_id;
                            this.updateStatus(`Workflow submitted. Prompt ID: ${this.currentPromptId}`, 'success');
                        } else {
                            throw new Error(`Server error: ${response.status}`);
                        }
                    } catch (error) {
                        this.updateStatus(`Execution failed: ${error.message}`, 'error');
                    }
                },

                async handleExecutionComplete(data) {
                    if (data.prompt_id === this.currentPromptId) {
                        this.updateStatus('Workflow execution completed', 'success');
                        this.progress = 'Complete';

                        try {
                            const historyResponse = await fetch(`${this.serverUrl}/history/${this.currentPromptId}`, {
                                mode: 'cors',
                                credentials: 'omit'
                            });
                            if (historyResponse.ok) {
                                const history = await historyResponse.json();
                                this.displayResults(history);
                            }
                        } catch (error) {
                            this.updateStatus(`Failed to fetch results: ${error.message}`, 'error');
                        }
                    }
                },

                displayResults(history) {
                    this.resultImages = [];

                    for (const [promptId, promptData] of Object.entries(history)) {
                        if (promptData.outputs) {
                            for (const [nodeId, nodeOutput] of Object.entries(promptData.outputs)) {
                                if (nodeOutput.images) {
                                    nodeOutput.images.forEach(image => {
                                        this.resultImages.push({
                                            src: `${this.serverUrl}/view?filename=${image.filename}&subfolder=${image.subfolder}&type=${image.type}`,
                                            alt: `Generated image from node ${nodeId}`
                                        });
                                    });
                                }
                            }
                        }
                    }
                },

                updateStatus(message, type = 'info') {
                    this.status = { message, type };
                },

                async registerServiceWorker() {
                    if ('serviceWorker' in navigator) {
                        try {
                            await navigator.serviceWorker.register('./sw.js');
                        } catch (error) {
                            console.warn('Service Worker registration failed');
                        }
                    }
                },

                // Endpoint management
                loadEndpoints() {
                    const saved = localStorage.getItem('aircomfy-endpoints');
                    if (saved) {
                        this.endpoints = JSON.parse(saved);
                    } else {
                        // Add default endpoint
                        this.endpoints = [
                            {
                                id: this.generateEndpointId(),
                                name: 'Local Server',
                                url: 'http://localhost:8188'
                            }
                        ];
                        this.saveEndpoints();
                    }
                },

                saveEndpoints() {
                    localStorage.setItem('aircomfy-endpoints', JSON.stringify(this.endpoints));
                },

                generateEndpointId() {
                    return 'endpoint-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
                },

                // View navigation
                showEndpointManager() {
                    this.currentView = 'endpoints';
                },

                showMainView() {
                    this.currentView = 'main';
                },

                selectEndpoint() {
                    const endpoint = this.endpoints.find(e => e.id === this.selectedEndpointId);
                    if (endpoint) {
                        this.serverUrl = endpoint.url;
                        this.saveSettings();
                        this.connectionStatus = 'Disconnected';
                    } else {
                        this.selectedEndpointId = '';
                        this.serverUrl = '';
                    }
                },

                addEndpoint() {
                    const name = this.newEndpoint.name.trim();
                    const url = this.newEndpoint.url.trim();

                    if (!name || !url) {
                        alert('Please enter both name and URL for the endpoint');
                        return;
                    }

                    try {
                        new URL(url); // Validate URL format
                    } catch (e) {
                        alert('Please enter a valid URL');
                        return;
                    }

                    const endpoint = {
                        id: this.generateEndpointId(),
                        name: name,
                        url: url
                    };

                    this.endpoints.push(endpoint);
                    this.saveEndpoints();

                    // Clear form
                    this.newEndpoint.name = '';
                    this.newEndpoint.url = '';
                },

                deleteEndpoint(endpointId) {
                    if (confirm('Are you sure you want to delete this endpoint?')) {
                        this.endpoints = this.endpoints.filter(e => e.id !== endpointId);
                        this.saveEndpoints();

                        // Clear selection if deleted endpoint was selected
                        if (this.selectedEndpointId === endpointId) {
                            this.selectedEndpointId = '';
                            this.serverUrl = '';
                            this.saveSettings();
                        }
                    }
                },

                editEndpoint(endpoint) {
                    const newName = prompt('Enter new name:', endpoint.name);
                    if (newName && newName.trim()) {
                        const newUrl = prompt('Enter new URL:', endpoint.url);
                        if (newUrl && newUrl.trim()) {
                            try {
                                new URL(newUrl); // Validate URL format
                                endpoint.name = newName.trim();
                                endpoint.url = newUrl.trim();
                                this.saveEndpoints();

                                // Update server URL if this endpoint is selected
                                if (this.selectedEndpointId === endpoint.id) {
                                    this.serverUrl = endpoint.url;
                                }
                            } catch (e) {
                                alert('Please enter a valid URL');
                            }
                        }
                    }
                }
            };
        }

        // Initialize the Vue app
        PetiteVue.createApp(AirComfyApp).mount();
    </script>
</body>
</html>